<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>TD Game</title>
<style>
  body {
    margin: 0; padding: 0; background: #222; font-family: sans-serif; color: #fff;
  }
  #ui {
    position: fixed; top: 10px; left: 10px; z-index: 10; display: flex; flex-direction: column; gap: 8px;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px;
  }
  button {
    padding: 6px 12px; font-weight: bold; cursor: pointer; border: none; border-radius: 4px; background:#3498db; color:#fff;
  }
  #gameCanvas {
    display: block; margin: 0 auto; background: #444; display: block;
  }
</style>
</head>
<body>

<div id="ui">
  <button id="startBtn">Начать игру</button>
  <button id="pauseBtn">Пауза</button>
  <button id="radiusBtn">Радиус: Вкл</button>
  <button id="indexBtn">Индексы: Вкл</button>
  <button id="questionMarksBtn" title="Показать шансы">?</button>
  <div>Жизни: <span id="lives">20</span></div>
  <div>Деньги: <span id="money">200</span></div>
  <div>Волна: <span id="wave">0</span></div>
  <div>Множитель: <span id="multiplier">1</span></div>
</div>

<canvas id="gameCanvas" width="820" height="500"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameRunning = false;
let paused = false;

// UI элементы
const livesEl = document.getElementById('lives');
const moneyEl = document.getElementById('money');
const waveEl = document.getElementById('wave');
const multiplierEl = document.getElementById('multiplier');

document.getElementById('startBtn').onclick = () => { startGame(); };
document.getElementById('pauseBtn').onclick = () => { paused = !paused; };
document.getElementById('radiusBtn').onclick = () => {
  showRadius = !showRadius;
  document.getElementById('radiusBtn').textContent = 'Радиус: ' + (showRadius ? 'Вкл' : 'Выкл');
};
document.getElementById('indexBtn').onclick = () => {
  showEnemyIndex = !showEnemyIndex;
  document.getElementById('indexBtn').textContent = 'Индексы: ' + (showEnemyIndex ? 'Вкл' : 'Выкл');
};
document.getElementById('questionMarksBtn').onclick = () => {
  alert('Шансы выпадения: ' + JSON.stringify(chanceDisplay));
};

let showRadius = true;
let showEnemyIndex = false;

// Настройки
let mapType = 'hills'; // hills, flat, mountains
let extremeMode = false;

// Путь
let path = [];
function setPath() {
  if (mapType === 'hills') {
    path = [
      {x: -20, y: 250},
      {x: 150, y: 250},
      {x: 150, y: 150},
      {x: 400, y: 150},
      {x: 400, y: 350},
      {x: 650, y: 350},
      {x: 650, y: 250},
      {x: 820, y: 250}
    ];
  } else if (mapType === 'flat') {
    path = [
      {x: -20, y: 250},
      {x: 820, y: 250}
    ];
  } else if (mapType === 'mountains') {
    path = [
      {x: -20, y: 250},
      {x: 100, y: 250},
      {x: 100, y: 100},
      {x: 200, y: 100},
      {x: 200, y: 400},
      {x: 300, y: 400},
      {x: 300, y: 150},
      {x: 500, y: 150},
      {x: 500, y: 350},
      {x: 700, y: 350},
      {x: 700, y: 200},
      {x: 820, y: 200}
    ];
  }
}
setPath();

// Переменные
let enemies = [];
let towers = [];
let bullets = [];

let wave = 0;
let lives = 20;
let money = 200;
let waveMultiplier = 1;
let totalDiamonds = 0;

let enemyIndex = [];
let chanceDisplay = {};

let spawnTimer = 0;
let enemiesToSpawn = 0;

// Пример новых башен сразу в игру (без инвентаря)
function addInitialTowers() {
  // Например, 2 башни
  towers.push({x: 300, y: 250, type: 'basic', range: 100, damage: 2, fireRate: 60});
  towers.push({x: 500, y: 150, type: 'basic', range: 100, damage: 2, fireRate: 60});
}

// Класс врага
class Enemy {
  constructor(type, health, speed, size, color) {
    this.type = type;
    this.health = health;
    this.maxHealth = health;
    this.speed = speed;
    this.size = size;
    this.color = color;
    this.x = path[0].x;
    this.y = path[0].y;
    this.pathIndex = 0;
    this.slowPercent = 0;
    this.healTimer = 0; // blue
    this.deleteTimer = 0; // void
    this.auraRadius = 0;
    if (type === 'boss') this.auraRadius = 4 * 10;
    if (type === 'blue') this.healTimer = 600; // 10 sec
    if (type === 'void') this.deleteTimer = 3600; // 60 sec

    // Заполнение шансов
    if (Object.keys(chanceDisplay).length === 0) {
      chanceDisplay = {
        'red': 0, 'purple': 0, 'golden': 0, 'pink': 0,
        'green': 0, 'white': 0, 'boss': 0, 'blue': 0,
        'sonic': 0, 'void': 0
      };
    }
    if (!enemyIndex.includes(type)) enemyIndex.push(type);
  }

  update() {
    // Обновление врагов
    if (this.type === 'white') {
      this.speedChangeTimer = (this.speedChangeTimer || 0) + 1;
      if (this.speedChangeTimer >= 60) {
        this.speedChangeTimer = 0;
        const greenSpeed = 1/3.15675434;
        const goldenSpeed = 2;
        this.speed = greenSpeed + Math.random() * (goldenSpeed - greenSpeed);
      }
    }
    if (this.type === 'blue') {
      this.healTimer--;
      if (this.healTimer <= 0) {
        this.healTimer = 600;
        for (let e of enemies) {
          if (e !== this) {
            e.health = Math.min(e.maxHealth, e.health + e.maxHealth * 0.5);
          }
        }
      }
    }
    if (this.type === 'void') {
      this.deleteTimer--;
      if (this.deleteTimer <= 0) {
        this.deleteTimer = 3600;
        // Удалить случайную башню кроме "омеги" (если есть)
        const nonOmegaTowers = towers.filter(t => t.type !== 'omega');
        if (nonOmegaTowers.length > 0) {
          const idx = Math.floor(Math.random() * nonOmegaTowers.length);
          towers.splice(towers.indexOf(nonOmegaTowers[idx]),1);
        }
      }
    }

    // Передвижение
    if (this.pathIndex < path.length - 1) {
      const target = path[this.pathIndex + 1];
      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const dist = Math.hypot(dx,dy);
      const moveSpeed = this.speed * (1 - this.slowPercent);
      if (dist < moveSpeed) {
        this.x = target.x;
        this.y = target.y;
        this.pathIndex++;
      } else {
        this.x += (dx / dist) * moveSpeed;
        this.y += (dy / dist) * moveSpeed;
      }
    } else {
      // достиг конца
      lives--;
      livesEl.textContent = lives;
      enemies.splice(enemies.indexOf(this),1);
      if (lives <= 0) {
        gameOver();
      }
    }
  }
  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();
    // здоровье
    ctx.fillStyle='black';
    ctx.fillRect(this.x - this.size, this.y - this.size - 5, this.size*2, 3);
    ctx.fillStyle='lime';
    ctx.fillRect(this.x - this.size, this.y - this.size - 5, this.size*2*(this.health/this.maxHealth), 3);
  }
}

// Вызов новых врагов
function spawnWave() {
  wave++;
  waveEl.textContent=wave;
  waveCountSinceLastReset++;
  if (wave % 5 === 0) {
    waveMultiplier += 0.2; // каждые 5 волн
  }
  enemiesToSpawn = 5 + Math.floor(wave/2);
  spawnTimer=0;
}

// Создаем врагов
function spawnEnemy() {
  const r = Math.random();
  let type='red';
  if (r<0.5) type='red';
  else if (r<0.7) type='purple';
  else if (r<0.8) type='golden';
  else if (r<0.85) type='pink';
  else if (r<0.9) type='green';
  else if (r<0.94) type='white';
  else if (r<0.97) type='boss';
  else if (r<0.985) type='blue';
  else if (r<0.995) type='sonic';
  else type='void';

  let health=10, speed=0.5, color='red';

  switch (type) {
    case 'red': health=10; color='red'; break;
    case 'purple': health=20; color='purple'; break;
    case 'golden': health=30; color='gold'; break;
    case 'pink': health=15; color='pink'; break;
    case 'green': health=10; color='lime'; break;
    case 'white': health=8; speed=0.8; color='white'; break;
    case 'boss': health=100; speed=0.3; color='orange'; break;
    case 'blue': health=12; speed=0.4; color='blue'; break;
    case 'sonic': health=8; speed=1.2; color='cyan'; break;
    case 'void': health=50; speed=0.3; color='black'; break;
  }

  if (extremeMode && type !== 'boss' && type !== 'void') {
    health *= 2;
  }

  enemies.push(new Enemy(type, health, speed, 10, color));
}

// Игра
function gameOver() {
  alert('Игра окончена!');
  gameRunning=false;
  // сброс множителя
  waveMultiplier=1;
}

function startGame() {
  lives=20; livesEl.textContent=lives;
  money=200; moneyEl.textContent=money;
  wave=0; waveEl.textContent=wave;
  waveMultiplier=1;
  enemies=[];
  towers=[];
  bullets=[];
  enemyIndex=[];
  chanceDisplay={};
  setPath();
  addInitialTowers(); // добавляем башни сразу
  spawnWave();
  gameRunning=true;
  gameLoop();
}

// Новые башни сразу в игру
addInitialTowers();

// Основной цикл
function gameLoop() {
  if (!gameRunning) return;
  if (paused) {
    requestAnimationFrame(gameLoop);
    return;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Рисуем путь
  ctx.strokeStyle='white'; ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
  ctx.stroke();

  // Спавн врагов
  if (enemiesToSpawn > 0) {
    spawnTimer++;
    if (spawnTimer >= 60) { // каждые 60 кадров (1 сек)
      spawnEnemy();
      enemiesToSpawn--;
      spawnTimer=0;
    }
  } else {
    if (enemies.length===0) {
      spawnWave();
    }
  }

  // Обновляем врагов
  for (let e of enemies) {
    e.update();
  }

  // Стрелы
  for (let b of bullets) {
    b.update();
  }

  // Башни
  for (let t of towers) {
    t.cooldown--;
    if (t.cooldown <= 0) {
      // искать врага в радиусе
      let target=null;
      let distMin=Infinity;
      for (let e of enemies) {
        const dist = Math.hypot(e.x - t.x, e.y - t.y);
        if (dist<=t.range && dist<distMin) {
          distMin=dist;
          target=e;
        }
      }
      if (target) {
        // стрелять
        bullets.push({x:t.x,y:t.y, target:target, damage:t.damage, speed:5});
        t.cooldown= t.fireRate;
      }
    }
  }

  // Стрелы
  for (let i=bullets.length-1; i>=0; i--) {
    let b=bullets[i];
    const dx = b.target.x - b.x;
    const dy = b.target.y - b.y;
    const dist = Math.hypot(dx,dy);
    if (dist < b.speed) {
      // попасть
      b.target.health -= b.damage;
      if (b.target.health <=0) {
        // убить врага
        enemies.splice(enemies.indexOf(b.target),1);
        // награды
        let reward=10 * waveMultiplier;
        money+=reward;
        moneyEl.textContent=money;
      }
      bullets.splice(i,1);
    } else {
      b.x += (dx/dist) * b.speed;
      b.y += (dy/dist) * b.speed;
    }
  }

  // Отрисовка врагов
  for (let e of enemies) {
    e.draw();
  }

  // Отрисовка башен
  for (let t of towers) {
    ctx.beginPath();
    ctx.arc(t.x, t.y, 15, 0, Math.PI*2);
    ctx.fillStyle='blue';
    ctx.fill();
    if (showRadius) {
      ctx.strokeStyle='rgba(0,0,255,0.2)';
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.range, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  // Статистика
  document.getElementById('wave').textContent=wave;
  document.getElementById('lives').textContent=lives;
  document.getElementById('money').textContent=money;
  document.getElementById('multiplier').textContent=waveMultiplier.toFixed(2);

  requestAnimationFrame(gameLoop);
}

// Запуск
// Можно добавить автоматический запуск или по кнопке
// startGame();

</script>
</body>
</html>
